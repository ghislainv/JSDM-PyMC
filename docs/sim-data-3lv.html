<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-06-30 Fri 10:06 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ordering species to correct for ineffective constraints in joint species distribution models with latent variables</title>
<meta name="author" content="Ghislain Vieilledent" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xz/fonts@1/serve/inter.css">
<link rel="stylesheet" href="style/new.css">
<link rel="stylesheet" href="style/mycss.css">
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Ordering species to correct for ineffective constraints in joint species distribution models with latent variables</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc678764">1. Installing PyMC in a Python virtual environment</a></li>
<li><a href="#orga209447">2. Import libraries</a></li>
<li><a href="#orgfeddc98">3. Functions</a></li>
<li><a href="#orge4113ef">4. Simulating data</a></li>
<li><a href="#org03c76f3">5. Model</a></li>
<li><a href="#orgecc88a7">6. Convergence and model performance</a>
<ul>
<li><a href="#orgf5f53c0">6.1. Plotting traces</a></li>
<li><a href="#orgf85baa2">6.2. Parameter estimates.</a></li>
<li><a href="#org138e901">6.3. Traces for constrained parameters</a>
<ul>
<li><a href="#org18b7635">6.3.1. Factor loadings on the diagonal</a></li>
<li><a href="#orga5adc77">6.3.2. Species with high factor loadings</a></li>
</ul>
</li>
<li><a href="#orgf485c97">6.4. Convergence criteria</a></li>
</ul>
</li>
<li><a href="#org761ec40">7. Correcting for species order</a>
<ul>
<li><a href="#orgd250a81">7.1. Sorting species</a></li>
<li><a href="#orgb9343f1">7.2. Statistical model</a></li>
<li><a href="#org54d8396">7.3. Convergence and model performance</a></li>
</ul>
</li>
<li><a href="#org1206a5b">8. Automatic sorting of species with PCAÂ on residuals</a>
<ul>
<li><a href="#org76abbb6">8.1. Unsorted data</a></li>
<li><a href="#org3963d26">8.2. Statistical model with residuals</a></li>
<li><a href="#orgd879598">8.3. PCA on residuals</a></li>
<li><a href="#org47266ba">8.4. Correlation between factor loadings and species coordinates on the two axis of the PCA</a></li>
<li><a href="#org889d93d">8.5. Statistical model with sorted species</a></li>
<li><a href="#orgce74850">8.6. Convergence and model performance</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-orgc678764" class="outline-2">
<h2 id="orgc678764"><span class="section-number-2">1.</span> Installing PyMC in a Python virtual environment</h2>
<div class="outline-text-2" id="text-1">
<p>
The best way to install the package is to create a Python virtual environment, for example using <code>conda</code>. You first need to have <a href="https://docs.conda.io/en/latest/miniconda.html">miniconda3</a> installed. Then, create a <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">conda environment</a> and install the PyMC package with the following commands:
</p>

<div class="org-src-container">
<pre class="src src-shell">conda create --name JSDM-PyMC -c conda-forge <span class="org-variable-name">python</span>=3.9
conda activate JSDM-PyMC
conda install -c conda-forge mamba
mamba install -c conda-forge <span class="org-string">"pymc&gt;=4"</span>
conda install -c conda-forge scikit-learn flake8 jedi tabular
</pre>
</div>

<p>
To deactivate and delete the conda environment, use the following commands:
</p>

<div class="org-src-container">
<pre class="src src-shell">conda deactivate
conda env remove --name JSDM-PyMC
</pre>
</div>
</div>
</div>

<div id="outline-container-orga209447" class="outline-2">
<h2 id="orga209447"><span class="section-number-2">2.</span> Import libraries</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> os
<span class="org-keyword">import</span> sys

<span class="org-keyword">import</span> arviz <span class="org-keyword">as</span> az
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> cloudpickle
<span class="org-keyword">import</span> pymc <span class="org-keyword">as</span> pm
<span class="org-keyword">import</span> pytensor.tensor <span class="org-keyword">as</span> pt
<span class="org-keyword">from</span> tabulate <span class="org-keyword">import</span> tabulate

<span class="org-builtin">print</span>(f<span class="org-string">"Running on PyMC v</span>{pm.__version__}<span class="org-string">"</span>)
</pre>
</div>

<pre class="example">
Running on PyMC v5.0.2
</pre>
</div>
</div>

<div id="outline-container-orgfeddc98" class="outline-2">
<h2 id="orgfeddc98"><span class="section-number-2">3.</span> Functions</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">inv_logit</span>(p):
    <span class="org-keyword">return</span> 1. / (1. + np.exp(-p))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge4113ef" class="outline-2">
<h2 id="orge4113ef"><span class="section-number-2">4.</span> Simulating data</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Set seed for repeatability</span>
<span class="org-variable-name">SEED</span> = 1234
<span class="org-variable-name">rng</span> = np.random.default_rng(SEED)

<span class="org-comment-delimiter"># </span><span class="org-comment">Number of sites and species</span>
<span class="org-variable-name">n_sites</span> = 100
<span class="org-variable-name">n_species</span> = 30
<span class="org-comment-delimiter"># </span><span class="org-comment">Number of explanatory variables (including intercept)</span>
<span class="org-variable-name">n_p</span> = 3
<span class="org-comment-delimiter"># </span><span class="org-comment">Number of latent variables</span>
<span class="org-variable-name">n_q</span> = 3

<span class="org-comment-delimiter"># </span><span class="org-comment">Ecological variables</span>
<span class="org-variable-name">Int</span> = np.array([1] * n_sites)
<span class="org-variable-name">x</span> = rng.normal(0, 1, size=n_sites * (n_p - 1))
X = np.concatenate((Int, x)).reshape(n_sites, n_p, order=<span class="org-string">"F"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"X.shape:"</span>)
<span class="org-builtin">print</span>(X.shape)
<span class="org-builtin">print</span>(<span class="org-string">"\nX[:5,]:"</span>)
<span class="org-builtin">print</span>(X[:5,])
<span class="org-comment-delimiter"># </span><span class="org-comment">Number of explicative variables</span>
n_p = X.shape[1]

<span class="org-comment-delimiter"># </span><span class="org-comment">Latent variables</span>
w = rng.normal(0, 1, size=n_sites * n_q)
W_target = w.reshape(n_sites, n_q)
<span class="org-builtin">print</span>(<span class="org-string">"\nW.target.shape:"</span>)
<span class="org-builtin">print</span>(W_target.shape)
<span class="org-builtin">print</span>(<span class="org-string">"\nW_target[:5,]:"</span>)
<span class="org-builtin">print</span>(W_target[:5,])
<span class="org-comment-delimiter"># </span><span class="org-comment">(Check that W_target are independant)</span>
R_W = np.corrcoef(W_target, rowvar=<span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"\nR_W:"</span>)
<span class="org-builtin">print</span>(R_W)

<span class="org-comment-delimiter"># </span><span class="org-comment">Fixed species effects beta</span>
beta_target = rng.uniform(-1, 1, n_p * n_species).reshape(n_species, n_p)

<span class="org-comment-delimiter"># </span><span class="org-comment">Factor loading lambda</span>
_lambda_target = rng.uniform(-1, 1, n_q * n_species).reshape(n_species, n_q)
<span class="org-comment-delimiter"># </span><span class="org-comment">Decreasing importance of the latent axis</span>
axis_imp =  np.arange(n_q, 0, -1)
lambda_target = _lambda_target * axis_imp[np.newaxis, :]
<span class="org-comment-delimiter"># </span><span class="org-comment">Constraints on lambda</span>
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_q):
     lambda_target[i, (i + 1):] = 0
<span class="org-comment-delimiter"># </span><span class="org-comment">Small negative values on diagonal</span>
lambda_target[np.arange(n_q), np.arange(n_q)] =  np.array([-0.1] * n_q)
<span class="org-comment-delimiter"># </span><span class="org-comment">Large positive values for following species</span>
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_q):
     lambda_target[n_q + i, i] = n_q - i
     lambda_target[n_q + i, (i + 1):] = 0
<span class="org-builtin">print</span>(<span class="org-string">"\nlambda_target.shape:"</span>)
<span class="org-builtin">print</span>(lambda_target.shape)
<span class="org-builtin">print</span>(<span class="org-string">"\nlambda_target[:6,]:"</span>)
<span class="org-builtin">print</span>(lambda_target[:6,])

<span class="org-comment-delimiter"># </span><span class="org-comment">Variance of random site effects </span>
sigma_alpha_target = 0.5
<span class="org-comment-delimiter"># </span><span class="org-comment">Random site effects</span>
alpha_target = rng.normal(loc=0, scale=sigma_alpha_target, size=n_sites)

<span class="org-comment-delimiter"># </span><span class="org-comment">Probabilities</span>
Xbeta_target = np.matmul(X, beta_target.transpose())
Wlambda_target = np.matmul(W_target, lambda_target.transpose()) 
logit_theta_target = alpha_target[:, np.newaxis] + Xbeta_target + Wlambda_target
theta_target = inv_logit(logit_theta_target)

<span class="org-comment-delimiter"># </span><span class="org-comment">Simulated occurrences</span>
Y = rng.binomial(n=1, p=theta_target)
<span class="org-builtin">print</span>(<span class="org-string">"\nY.shape:"</span>)
<span class="org-builtin">print</span>(Y.shape)

<span class="org-comment-delimiter"># </span><span class="org-comment">Save data-set</span>
out_dir = <span class="org-string">"outputs/sim-data-3lv/"</span>
<span class="org-keyword">with</span> <span class="org-builtin">open</span>(out_dir + <span class="org-string">"data.pkl"</span>, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> f:
     data_dump = cloudpickle.dumps({<span class="org-string">"Y"</span>: Y, <span class="org-string">"X"</span>: X})
     f.write(data_dump)
</pre>
</div>

<pre class="example" id="org2022a17">
X.shape:
(100, 3)

X[:5,]:
[[ 1.         -1.60383681  2.25392546]
 [ 1.          0.06409991  0.1616142 ]
 [ 1.          0.7408913   0.83377881]
 [ 1.          0.15261919 -1.58010947]
 [ 1.          0.86374389  1.01058529]]

W.target.shape:
(100, 3)

W_target[:5,]:
[[ 0.73118867 -0.22964706  2.14411198]
 [ 0.39714586  0.15946658  0.38766429]
 [ 1.21467102  0.3130316   0.21977825]
 [ 0.25134426  1.89918969  0.07872037]
 [-1.35192047 -0.77074077 -0.4906274 ]]

R_W:
[[ 1.          0.13194801 -0.09843743]
 [ 0.13194801  1.          0.18699235]
 [-0.09843743  0.18699235  1.        ]]

lambda_target.shape:
(30, 3)

lambda_target[:6,]:
[[-0.1         0.          0.        ]
 [ 2.90645404 -0.1         0.        ]
 [-2.27666772 -1.54762031 -0.1       ]
 [ 3.          0.          0.        ]
 [-2.97255492  2.          0.        ]
 [-0.66112848 -0.75376636  1.        ]]

Y.shape:
(100, 30)
</pre>

<p>
Histogram of Wlambda.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = os.path.join(out_dir, <span class="org-string">"hist_Wlambda.png"</span>)
<span class="org-variable-name">fig</span> = plt.figure()
plt.hist(Wlambda_target.flatten(), bins=20)
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="orgc9d0cd5">
<img src="outputs/sim-data-3lv/hist_Wlambda.png" alt="hist_Wlambda.png">

</figure>
</div>
</div>

<div id="outline-container-org03c76f3" class="outline-2">
<h2 id="org03c76f3"><span class="section-number-2">5.</span> Model</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">Lambda0</span> = pt.eye(n_species, n_q)
<span class="org-variable-name">HALFNORMAL_SCALE</span> = 1. / np.sqrt(1. - 2. / np.pi)
</pre>
</div>

<p>
We create a function to expand a packed block triangular matrix. Triangular matrices can be stored with better space efficiency by storing the non-zero values in a one-dimensional array. This function is an adaptation of <code>pm.expand.packed.triangular</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">expand_packed_block_triangular</span>(n_species, n_q, packed, diag=<span class="org-constant">None</span>, mtype=<span class="org-string">"pytensor"</span>):
    <span class="org-comment-delimiter"># </span><span class="org-comment">like pm.expand_packed_triangular, but with n_species &gt; n_q.</span>
    <span class="org-keyword">assert</span> mtype <span class="org-keyword">in</span> {<span class="org-string">"pytensor"</span>, <span class="org-string">"numpy"</span>}
    <span class="org-keyword">assert</span> n_species &gt;= n_q

    <span class="org-keyword">def</span> <span class="org-function-name">set_</span>(M, i_, v_):
        <span class="org-keyword">if</span> mtype == <span class="org-string">"pytensor"</span>:
            <span class="org-keyword">return</span> pt.set_subtensor(M[i_], v_)
        M[<span class="org-variable-name">i_</span>] = v_
        <span class="org-keyword">return</span> M

    out = pt.zeros((n_species, n_q), dtype=<span class="org-builtin">float</span>) <span class="org-keyword">if</span> mtype == <span class="org-string">"pytensor"</span> <span class="org-keyword">else</span> np.zeros((n_species, n_q), dtype=<span class="org-builtin">float</span>)
    <span class="org-keyword">if</span> diag <span class="org-keyword">is</span> <span class="org-constant">None</span>:
        idxs = np.tril_indices(n_species, m=n_q)
        out = set_(out, idxs, packed)
    <span class="org-keyword">else</span>:
        idxs = np.tril_indices(n_species, k=-1, m=n_q)
        out = set_(out, idxs, packed)
        idxs = (np.arange(n_q), np.arange(n_q))
        out = set_(out, idxs, diag)
    <span class="org-keyword">return</span> out
</pre>
</div>

<p>
We define another function which helps create a diagonal matrix with positive values on the diagonal.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">makeLambda</span>(n_species, n_q, dim_names):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Number of below diagonal factor loadings</span>
    <span class="org-variable-name">n_L_packed</span> = <span class="org-builtin">int</span>(n_species * n_q - n_q * (n_q - 1) / 2 - n_q)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Diagonal matrix</span>
    <span class="org-variable-name">L_diag</span> = pm.HalfNormal(<span class="org-string">"L_diag"</span>, sigma=HALFNORMAL_SCALE, shape=n_q)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Packed Lambda</span>
    L_packed = pm.Normal(<span class="org-string">"L_packed"</span>, mu=0, sigma=1, shape=n_L_packed)
    L = expand_packed_block_triangular(n_species, n_q, L_packed, diag=pt.ones(n_q))
    Lambda = pm.Deterministic(<span class="org-string">"Lambda"</span>, pt.dot(L, pt.diag(L_diag)), dims=dim_names)
    <span class="org-keyword">return</span> Lambda
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> pm.Model() <span class="org-keyword">as</span> <span class="org-variable-name">model</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Hyperpriors</span>
    sigma_alpha = pm.HalfNormal(<span class="org-string">"sigma_alpha"</span>, sigma=1.0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Priors</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Site random effect</span>
    alpha = pm.Normal(<span class="org-string">"alpha"</span>, mu=0, sigma=sigma_alpha, shape=n_sites, dims=<span class="org-string">"sites"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Latent variables</span>
    W = pm.Normal(<span class="org-string">"W"</span>, mu=0, sigma=1, shape=(n_sites, n_q), dims=(<span class="org-string">"sites"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Species effects</span>
    beta = pm.Normal(<span class="org-string">"beta"</span>, mu=0, sigma=1, shape=(n_species, n_p), dims=(<span class="org-string">"species"</span>, <span class="org-string">"fixed_effects"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Factor loadings with constraints</span>
    Lambda = makeLambda(n_species, n_q, (<span class="org-string">"species"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Likelihood</span>
    Xbeta = pm.math.dot(X, beta.transpose())
    Wlambda = pm.math.dot(W, Lambda.transpose()) 
    logit_theta = alpha[:, np.newaxis] + Xbeta + Wlambda
    obs = pm.Bernoulli(<span class="org-string">"obs"</span>, logit_p=logit_theta, observed=Y)
</pre>
</div>

<p>
Parameters for MCMC sampling:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">CORES</span> = 2
<span class="org-variable-name">SAMPLE_KWARGS</span> = {
    <span class="org-string">'draws'</span>: 1000,
    <span class="org-string">'cores'</span>: CORES,
    <span class="org-string">'init'</span>: <span class="org-string">'auto'</span>,
    <span class="org-string">'tune'</span>: 1000,
    <span class="org-string">'random_seed'</span>: [SEED + i <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(CORES)]
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Inference</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    trace = pm.sample(**SAMPLE_KWARGS)
</pre>
</div>

<p>
Save model with cloudpickle (cf. <a href="https://github.com/pymc-devs/pymc/issues/5886">link</a>).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace.pkl"</span>, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> <span class="org-variable-name">f</span>:
     model_trace_dump = cloudpickle.dumps({<span class="org-string">'model'</span>: model, <span class="org-string">'trace'</span>: trace})
     f.write(model_trace_dump)
</pre>
</div>

<p>
Then, model results can be loaded with the following code (set :eval yes):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">f</span> = <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace.pkl"</span>, <span class="org-string">"rb"</span>)
<span class="org-variable-name">model_trace</span> = cloudpickle.loads(f.read())
</pre>
</div>
</div>
</div>

<div id="outline-container-orgecc88a7" class="outline-2">
<h2 id="orgecc88a7"><span class="section-number-2">6.</span> Convergence and model performance</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgf5f53c0" class="outline-3">
<h3 id="orgf5f53c0"><span class="section-number-3">6.1.</span> Plotting traces</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"trace.png"</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    axes = az.plot_trace(trace,
                         var_names=[<span class="org-string">"alpha"</span>, <span class="org-string">"beta"</span>,
                                    <span class="org-string">"sigma_alpha"</span>])
fig = axes.ravel()[0].figure
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="org5abe34f">
<img src="outputs/sim-data-3lv/trace.png" alt="trace.png" width="900">

</figure>
</div>
</div>

<div id="outline-container-orgf85baa2" class="outline-3">
<h3 id="orgf85baa2"><span class="section-number-3">6.2.</span> Parameter estimates.</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    summary = az.summary(trace,
                         var_names=[<span class="org-string">"alpha"</span>, <span class="org-string">"beta"</span>,
                                    <span class="org-string">"sigma_alpha"</span>], round_to=2)
summary.to_csv(out_dir + <span class="org-string">"model_summary.txt"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    alpha_est = az.summary(trace, var_names=[<span class="org-string">"alpha"</span>], round_to=2)
    beta_est = az.summary(trace, var_names=[<span class="org-string">"beta"</span>], round_to=2)
    lambda_diag_est = az.summary(trace,
                                 var_names=[<span class="org-string">"L_diag"</span>],
                                 round_to=2)
    lambda_offdiag_est = az.summary(trace,
                                    var_names=[<span class="org-string">"L_packed"</span>],
                                    round_to=2)
    lambda_est = az.summary(trace,
                            var_names=[<span class="org-string">"Lambda"</span>],
                            round_to=2)
    W_diag_est = az.summary(trace, var_names=[<span class="org-string">"W"</span>],
                            coords={<span class="org-string">"sites"</span>: np.arange(n_q),
                                    <span class="org-string">"latent_axis"</span>: np.arange(n_q)},
                            round_to=2)
    W_est = az.summary(trace, var_names=[<span class="org-string">"W"</span>],
                            round_to=2)
</pre>
</div>
</div>
</div>

<div id="outline-container-org138e901" class="outline-3">
<h3 id="org138e901"><span class="section-number-3">6.3.</span> Traces for constrained parameters</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-org18b7635" class="outline-4">
<h4 id="org18b7635"><span class="section-number-4">6.3.1.</span> Factor loadings on the diagonal</h4>
<div class="outline-text-4" id="text-6-3-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"trace_lambda_diag.png"</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    axes = az.plot_trace(trace.posterior[<span class="org-string">"L_diag"</span>],
                         var_names=[<span class="org-string">"L_diag"</span>], compact=<span class="org-constant">False</span>)
fig = axes.ravel()[0].figure
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="org78fc096">
<img src="outputs/sim-data-3lv/trace_lambda_diag.png" alt="trace_lambda_diag.png" width="900">

</figure>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"trace_lambda_0_0.png"</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    axes = az.plot_trace(trace,
                         var_names=[<span class="org-string">"Lambda"</span>],
                         coords={<span class="org-string">"species"</span>: [0],
                                 <span class="org-string">"latent_axis"</span>: [0]})
fig = axes.ravel()[0].figure
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="org581f51a">
<img src="outputs/sim-data-3lv/trace_lambda_0_0.png" alt="trace_lambda_0_0.png" width="900">

</figure>

<p>
For these lambdas, MCMCs do not converge (r_hat &gt;&gt; 1) and posteriors means are far from the target values of -0.1.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">lambda_diag</span> = lambda_diag_est.loc[:, [<span class="org-string">"mean"</span>, <span class="org-string">"sd"</span>, <span class="org-string">"r_hat"</span>]]
<span class="org-variable-name">lambda_diag</span>[<span class="org-string">"target_value"</span>] = np.diag(lambda_target)
tabulate(lambda_diag, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">True</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">sd</th>
<th scope="col" class="org-right">r_hat</th>
<th scope="col" class="org-right">target_value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">L_diag[0]</td>
<td class="org-right">0.92</td>
<td class="org-right">0.6</td>
<td class="org-right">1.83</td>
<td class="org-right">-0.1</td>
</tr>

<tr>
<td class="org-left">L_diag[1]</td>
<td class="org-right">1.51</td>
<td class="org-right">1.24</td>
<td class="org-right">1.85</td>
<td class="org-right">-0.1</td>
</tr>

<tr>
<td class="org-left">L_diag[2]</td>
<td class="org-right">1.36</td>
<td class="org-right">0.25</td>
<td class="org-right">1.04</td>
<td class="org-right">-0.1</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga5adc77" class="outline-4">
<h4 id="orga5adc77"><span class="section-number-4">6.3.2.</span> Species with high factor loadings</h4>
<div class="outline-text-4" id="text-6-3-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"trace_lambda_high_loadings.png"</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    axes = az.plot_trace(trace,
                         var_names=[<span class="org-string">"Lambda"</span>],
                         coords={<span class="org-string">"species"</span>: np.arange(3, 6),
                                 <span class="org-string">"latent_axis"</span>: np.arange(0, 3)},
                         compact=<span class="org-constant">False</span>)
fig = axes.ravel()[0].figure
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="org0a319ed">
<img src="outputs/sim-data-3lv/trace_lambda_high_loadings.png" alt="trace_lambda_high_loadings.png" width="900">

</figure>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"trace_lambda_3_0.png"</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model</span>:
    axes = az.plot_trace(trace,
                         var_names=[<span class="org-string">"Lambda"</span>],
                         coords={<span class="org-string">"species"</span>: [3],
                                 <span class="org-string">"latent_axis"</span>: [0]})
fig = axes.ravel()[0].figure
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="orgf048ed6">
<img src="outputs/sim-data-3lv/trace_lambda_3_0.png" alt="trace_lambda_3_0.png" width="900">

</figure>

<p>
For species with high factor loadings, MCMCs do not converge (r_hat &gt;&gt; 1) and posteriors means are far from the target values of 3, 2, and 1.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">lambda_high</span> = lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"mean"</span>, <span class="org-string">"sd"</span>, <span class="org-string">"r_hat"</span>]]
<span class="org-variable-name">lambda_high</span>[<span class="org-string">"target_value"</span>] = [lambda_target[3, 0], lambda_target[4, 1], lambda_target[5, 2]]
tabulate(lambda_high, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">True</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">sd</th>
<th scope="col" class="org-right">r_hat</th>
<th scope="col" class="org-right">target_value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Lambda[3, 0]</td>
<td class="org-right">1.28</td>
<td class="org-right">1.32</td>
<td class="org-right">1.83</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">Lambda[4, 1]</td>
<td class="org-right">-1.26</td>
<td class="org-right">1.27</td>
<td class="org-right">1.83</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Lambda[5, 2]</td>
<td class="org-right">-0.49</td>
<td class="org-right">0.34</td>
<td class="org-right">1.02</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgf485c97" class="outline-3">
<h3 id="orgf485c97"><span class="section-number-3">6.4.</span> Convergence criteria</h3>
<div class="outline-text-3" id="text-6-4">
<p>
We compute the mean r_hat for each category of parameters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Compute r_hat mean and std</span>
<span class="org-variable-name">rhat_alpha_mean</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_alpha_std</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_beta_mean</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_beta_std</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_W_mean</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_W_std</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_mean</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_std</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_diag_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_diag_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_high_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_high_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)

<span class="org-comment-delimiter"># </span><span class="org-comment">Build dataframe</span>
<span class="org-variable-name">par_names</span> = [<span class="org-string">"alpha"</span>, <span class="org-string">"beta"</span>, <span class="org-string">"W"</span>, <span class="org-string">"lambda"</span>, <span class="org-string">"lambda_diag"</span>, <span class="org-string">"lambda_high"</span>]
<span class="org-variable-name">mean_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_mean"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]
<span class="org-variable-name">std_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_std"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]

<span class="org-variable-name">rhat_dic</span> = {<span class="org-string">"par"</span>: par_names,
            <span class="org-string">"r_hat_mean"</span>: mean_val, <span class="org-string">"rhat_std"</span>: std_val}
<span class="org-variable-name">rhat_df</span> = pd.DataFrame(rhat_dic)
tabulate(rhat_df, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">False</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">par</th>
<th scope="col" class="org-right">r_hat_mean</th>
<th scope="col" class="org-right">rhat_std</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alpha</td>
<td class="org-right">1.01</td>
<td class="org-right">0.01</td>
</tr>

<tr>
<td class="org-left">beta</td>
<td class="org-right">1.01</td>
<td class="org-right">0.02</td>
</tr>

<tr>
<td class="org-left">W</td>
<td class="org-right">1.21</td>
<td class="org-right">0.17</td>
</tr>

<tr>
<td class="org-left">lambda</td>
<td class="org-right">1.46</td>
<td class="org-right">0.39</td>
</tr>

<tr>
<td class="org-left">lambda_diag</td>
<td class="org-right">1.57</td>
<td class="org-right">0.46</td>
</tr>

<tr>
<td class="org-left">lambda_high</td>
<td class="org-right">1.56</td>
<td class="org-right">0.47</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org761ec40" class="outline-2">
<h2 id="org761ec40"><span class="section-number-2">7.</span> Correcting for species order</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgd250a81" class="outline-3">
<h3 id="orgd250a81"><span class="section-number-3">7.1.</span> Sorting species</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Species with high factor values are used for constraints.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">f</span> = <span class="org-builtin">open</span>(out_dir + <span class="org-string">"data.pkl"</span>, <span class="org-string">"rb"</span>)
<span class="org-variable-name">data</span> = cloudpickle.loads(f.read())
<span class="org-variable-name">Y</span> = data[<span class="org-string">"Y"</span>]
<span class="org-variable-name">Y_sort</span> = np.copy(Y)
<span class="org-variable-name">Y_sort</span>[:, 0] = Y[:, 3]
<span class="org-variable-name">Y_sort</span>[:, 1] = Y[:, 4]
<span class="org-variable-name">Y_sort</span>[:, 2] = Y[:, 5]
<span class="org-variable-name">Y_sort</span>[:, 3] = Y[:, 0]
<span class="org-variable-name">Y_sort</span>[:, 4] = Y[:, 1]
<span class="org-variable-name">Y_sort</span>[:, 5] = Y[:, 2]
<span class="org-variable-name">Y</span> = Y_sort
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb9343f1" class="outline-3">
<h3 id="orgb9343f1"><span class="section-number-3">7.2.</span> Statistical model</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> pm.Model() <span class="org-keyword">as</span> <span class="org-variable-name">model_sort</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Hyperpriors</span>
    sigma_alpha = pm.HalfNormal(<span class="org-string">"sigma_alpha"</span>, sigma=1.0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Priors</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Site random effect</span>
    alpha = pm.Normal(<span class="org-string">"alpha"</span>, mu=0, sigma=sigma_alpha, shape=n_sites, dims=<span class="org-string">"sites"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Latent variables</span>
    W = pm.Normal(<span class="org-string">"W"</span>, mu=0, sigma=1, shape=(n_sites, n_q), dims=(<span class="org-string">"sites"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Species effects</span>
    beta = pm.Normal(<span class="org-string">"beta"</span>, mu=0, sigma=1, shape=(n_species, n_p), dims=(<span class="org-string">"species"</span>, <span class="org-string">"fixed_effects"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Factor loadings with constraints</span>
    Lambda = makeLambda(n_species, n_q, (<span class="org-string">"species"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Likelihood</span>
    Xbeta = pm.math.dot(X, beta.transpose())
    Wlambda = pm.math.dot(W, Lambda.transpose()) 
    logit_theta = alpha[:, np.newaxis] + Xbeta + Wlambda
    obs = pm.Bernoulli(<span class="org-string">"obs"</span>, logit_p=logit_theta, observed=Y)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Inference</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model_sort</span>:
    trace_sort = pm.sample(**SAMPLE_KWARGS)
</pre>
</div>

<p>
Save model with cloudpickle.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace_sort.pkl"</span>, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> <span class="org-variable-name">f</span>:
     model_trace_dump = cloudpickle.dumps({<span class="org-string">'model'</span>: model_sort, <span class="org-string">'trace'</span>: trace_sort})
     f.write(model_trace_dump)
</pre>
</div>

<p>
Load model if necessary (set :eval yes).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">f</span> = <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace_sort.pkl"</span>, <span class="org-string">"rb"</span>)
<span class="org-variable-name">model_trace</span> = cloudpickle.loads(f.read())
<span class="org-variable-name">model_sort</span> = model_trace[<span class="org-string">"model"</span>]
<span class="org-variable-name">trace_sort</span> = model_trace[<span class="org-string">"trace"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-org54d8396" class="outline-3">
<h3 id="org54d8396"><span class="section-number-3">7.3.</span> Convergence and model performance</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-variable-name">model_sort</span>:
    alpha_est = az.summary(trace_sort, var_names=[<span class="org-string">"alpha"</span>], round_to=2)
    beta_est = az.summary(trace_sort, var_names=[<span class="org-string">"beta"</span>], round_to=2)
    lambda_diag_est = az.summary(trace_sort,
                                 var_names=[<span class="org-string">"L_diag"</span>],
                                 round_to=2)
    lambda_offdiag_est = az.summary(trace_sort,
                                    var_names=[<span class="org-string">"L_packed"</span>],
                                    round_to=2)
    lambda_est = az.summary(trace_sort,
                            var_names=[<span class="org-string">"Lambda"</span>],
                            round_to=2)
    W_diag_est = az.summary(trace_sort, var_names=[<span class="org-string">"W"</span>],
                            coords={<span class="org-string">"sites"</span>: np.arange(n_q),
                                    <span class="org-string">"latent_axis"</span>: np.arange(n_q)},
                            round_to=2)
    W_est = az.summary(trace_sort, var_names=[<span class="org-string">"W"</span>],
                            round_to=2)
</pre>
</div>

<p>
We compute the mean r_hat for each category of parameters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Compute r_hat mean and std</span>
<span class="org-variable-name">rhat_alpha_mean</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_alpha_std</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_beta_mean</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_beta_std</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_W_mean</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_W_std</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_mean</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_std</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_diag_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_diag_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_high_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_high_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)

<span class="org-comment-delimiter"># </span><span class="org-comment">Build dataframe</span>
<span class="org-variable-name">par_names</span> = [<span class="org-string">"alpha"</span>, <span class="org-string">"beta"</span>, <span class="org-string">"W"</span>, <span class="org-string">"lambda"</span>, <span class="org-string">"lambda_diag"</span>, <span class="org-string">"lambda_high"</span>]
<span class="org-variable-name">mean_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_mean"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]
<span class="org-variable-name">std_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_std"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]

<span class="org-variable-name">rhat_dic</span> = {<span class="org-string">"par"</span>: par_names,
            <span class="org-string">"r_hat_mean"</span>: mean_val, <span class="org-string">"rhat_std"</span>: std_val}
<span class="org-variable-name">rhat_df</span> = pd.DataFrame(rhat_dic)
tabulate(rhat_df, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">False</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">par</th>
<th scope="col" class="org-right">r_hat_mean</th>
<th scope="col" class="org-right">rhat_std</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alpha</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">beta</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">W</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">lambda</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">lambda_diag</td>
<td class="org-right">1</td>
<td class="org-right">0.01</td>
</tr>

<tr>
<td class="org-left">lambda_high</td>
<td class="org-right">1</td>
<td class="org-right">0.01</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org1206a5b" class="outline-2">
<h2 id="org1206a5b"><span class="section-number-2">8.</span> Automatic sorting of species with PCAÂ on residuals</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org76abbb6" class="outline-3">
<h3 id="org76abbb6"><span class="section-number-3">8.1.</span> Unsorted data</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">f</span> = <span class="org-builtin">open</span>(out_dir + <span class="org-string">"data.pkl"</span>, <span class="org-string">"rb"</span>)
<span class="org-variable-name">data</span> = cloudpickle.loads(f.read())
<span class="org-variable-name">Y</span> = data[<span class="org-string">"Y"</span>]
<span class="org-variable-name">X</span> = data[<span class="org-string">"X"</span>]
<span class="org-builtin">print</span>(<span class="org-string">"X.shape:"</span>)
<span class="org-builtin">print</span>(X.shape)
<span class="org-builtin">print</span>(<span class="org-string">"\nX[:5,]:"</span>)
<span class="org-builtin">print</span>(X[:5,])
<span class="org-builtin">print</span>(<span class="org-string">"\nY.shape:"</span>)
<span class="org-builtin">print</span>(Y.shape)
</pre>
</div>

<pre class="example" id="org6aac028">
X.shape:
(100, 3)

X[:5,]:
[[ 1.         -1.60383681  2.25392546]
 [ 1.          0.06409991  0.1616142 ]
 [ 1.          0.7408913   0.83377881]
 [ 1.          0.15261919 -1.58010947]
 [ 1.          0.86374389  1.01058529]]

Y.shape:
(100, 30)
</pre>
</div>
</div>

<div id="outline-container-org3963d26" class="outline-3">
<h3 id="org3963d26"><span class="section-number-3">8.2.</span> Statistical model with residuals</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> pm.Model() <span class="org-keyword">as</span> <span class="org-variable-name">model_res</span>:   
    <span class="org-comment-delimiter"># </span><span class="org-comment">Hyperpriors</span>
    sigma_alpha = pm.HalfNormal(<span class="org-string">"sigma_alpha"</span>, sigma=1.0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Priors</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Site random effect</span>
    alpha = pm.Normal(<span class="org-string">"alpha"</span>, mu=0, sigma=sigma_alpha, shape=n_sites)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Species effects</span>
    beta = pm.Normal(<span class="org-string">"beta"</span>, mu=0, sigma=1, shape=(n_species, n_p))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Likelihood</span>
    Xbeta = pm.math.dot(X, beta.transpose())
    m = pm.Deterministic(<span class="org-string">"mu"</span>, alpha[:, np.newaxis] + Xbeta)
    logit_theta = pm.Normal(<span class="org-string">"logit_theta"</span>, mu=m, sigma=1)
    e = pm.Deterministic(<span class="org-string">"error"</span>, logit_theta - m)
    obs = pm.Bernoulli(<span class="org-string">"obs"</span>, logit_p=logit_theta, observed=Y)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Inference</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model_res</span>:
    trace_res = pm.sample(**SAMPLE_KWARGS)
</pre>
</div>

<p>
Save model with cloudpickle.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace_res.pkl"</span>, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> <span class="org-variable-name">f</span>:
     model_trace_dump = cloudpickle.dumps({<span class="org-string">'model'</span>: model_res, <span class="org-string">'trace'</span>: trace_res})
     f.write(model_trace_dump)
</pre>
</div>

<p>
Get residuals.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-variable-name">model_res</span>:
    error_est = az.summary(trace_res, var_names=[<span class="org-string">"error"</span>], round_to=2)
e = np.asarray(error_est[<span class="org-string">"mean"</span>]).reshape(n_sites, n_species)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = os.path.join(out_dir, <span class="org-string">"hist_residuals.png"</span>)
<span class="org-variable-name">fig</span> = plt.figure()
plt.hist(e.flatten(), bins=20)
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="orgbdfedb0">
<img src="outputs/sim-data-3lv/hist_residuals.png" alt="hist_residuals.png">

</figure>

<p>
Correlation between residuals and Wlambda.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = out_dir + <span class="org-string">"corr_res_Wlambda.png"</span>
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(figsize=(6, 6))
ax.scatter(Wlambda_target, e, c=<span class="org-string">".3"</span>)
ax.axline((1, 1), slope=1, ls=<span class="org-string">"--"</span>, c=<span class="org-string">".3"</span>)
ax.set_xlabel(<span class="org-string">"Wlambda_target"</span>)
ax.set_ylabel(<span class="org-string">"Estimated residuals"</span>)
ax.set_title(<span class="org-string">"corr_res_Wlambda"</span>)
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="org4d9e467">
<img src="outputs/sim-data-3lv/corr_res_Wlambda.png" alt="corr_res_Wlambda.png">

</figure>
</div>
</div>

<div id="outline-container-orgd879598" class="outline-3">
<h3 id="orgd879598"><span class="section-number-3">8.3.</span> PCA on residuals</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Make the PCA on residuals to find the coordinates of the species on two axis.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> sklearn.decomposition <span class="org-keyword">import</span> PCA
<span class="org-keyword">from</span> sklearn.preprocessing <span class="org-keyword">import</span> StandardScaler

<span class="org-variable-name">pca</span> = PCA(n_components=3)
e_cr = StandardScaler().fit_transform(e)
pca_features = pca.fit_transform(e_cr)
pca_features.shape
<span class="org-builtin">print</span>(pca.explained_variance_ratio_)
</pre>
</div>

<pre class="example">
[0.27461966 0.11280302 0.05412956]
</pre>


<p>
Here, the first axis explains 27% of the inertia while the second axis explains only about half (11%).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">pca_comp</span> = pca.components_.transpose()
<span class="org-builtin">print</span>(pca_comp)
</pre>
</div>

<pre class="example" id="orga3cffa9">
[[ 1.94429083e-02  4.50829023e-02 -1.53741760e-01]
 [-2.64964102e-01  6.33756619e-02  7.49584684e-02]
 [ 2.11243680e-01 -2.91047536e-01 -1.89630527e-05]
 [-2.35152503e-01  1.07436354e-01  1.33379610e-03]
 [ 2.23679241e-01  1.98729016e-01 -1.54303551e-01]
 [ 1.12038922e-01  5.24427278e-02  4.33911530e-01]
 [ 1.66923544e-01  2.35174499e-01  1.24692071e-01]
 [ 2.53397685e-01  6.29642082e-02 -1.36564856e-01]
 [-1.45355801e-02 -2.79373068e-02  1.03988520e-01]
 [ 2.10240857e-01  1.29147328e-01 -1.70065265e-01]
 [ 2.29399672e-01  1.66860450e-01  2.21139620e-01]
 [ 7.23168914e-02 -3.33268922e-01 -1.01689862e-01]
 [ 4.07709973e-02  1.33442987e-01  3.96189176e-01]
 [ 2.17065364e-01 -1.25439084e-01 -1.03127525e-01]
 [ 1.16353458e-01 -2.89185154e-01  3.11168845e-01]
 [ 4.14468368e-02  9.06986101e-02 -4.42362961e-01]
 [ 1.50589024e-01 -2.74107627e-01 -7.91453139e-02]
 [-1.69836149e-01 -2.27877817e-01  2.58124142e-02]
 [-9.54757576e-02 -2.54200132e-01  3.14677851e-02]
 [ 2.83297789e-01  2.37504431e-02 -2.55550141e-05]
 [-6.91087807e-02 -2.45794134e-01  4.78123466e-02]
 [-2.39621580e-01  7.74325469e-02  4.45646849e-02]
 [-2.69835497e-01 -7.65776269e-02 -7.19052191e-03]
 [-1.90826926e-01 -4.69117088e-02  1.16519082e-01]
 [ 2.01292197e-01 -4.03069537e-02  9.17429990e-02]
 [-1.35073764e-02  2.56105299e-01 -1.55353580e-01]
 [-2.38143911e-01  1.46176962e-01  1.76227953e-01]
 [-8.39425185e-02  3.46513565e-01  3.11272769e-02]
 [-2.21620246e-01  5.83048043e-02 -2.13420160e-01]
 [ 2.06503520e-01  1.88797690e-01  1.71518804e-01]]
</pre>

<p>
Identify the species which influences most each component.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">pca_comp_abs</span> = np.<span class="org-builtin">abs</span>(pca_comp)
<span class="org-variable-name">sp_sel</span> = np.argmax(pca_comp_abs, axis=0)
<span class="org-builtin">print</span>(sp_sel)
</pre>
</div>

<pre class="example">
[19 27 15]
</pre>


<p>
We correctly identified the two species. We look again at the factor loadings for these two species.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(lambda_target[sp_sel, :])
</pre>
</div>

<pre class="example">
[[-2.88754458  0.29394575 -0.42235855]
 [ 0.70220339  1.90120307  0.81997005]
 [-0.91670261  0.89557285 -0.82867678]]
</pre>


<p>
Sorting species.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">Y_sort</span> = np.copy(Y)
<span class="org-variable-name">Y_sort</span>[:, 0] = Y[:, sp_sel[0]]
<span class="org-variable-name">Y_sort</span>[:, 1] = Y[:, sp_sel[1]]
<span class="org-variable-name">Y_sort</span>[:, 2] = Y[:, sp_sel[2]]
Y_sort[:, sp_sel[0]] = Y[:, 0]
Y_sort[:, sp_sel[1]] = Y[:, 1]
Y_sort[:, sp_sel[2]] = Y[:, 2]
<span class="org-variable-name">Y</span> = Y_sort
</pre>
</div>
</div>
</div>

<div id="outline-container-org47266ba" class="outline-3">
<h3 id="org47266ba"><span class="section-number-3">8.4.</span> Correlation between factor loadings and species coordinates on the two axis of the PCA</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">cor</span> = np.corrcoef(np.<span class="org-builtin">abs</span>(lambda_target.flatten()), np.<span class="org-builtin">abs</span>(pca_comp.flatten()))
<span class="org-builtin">print</span>(cor)
</pre>
</div>

<pre class="example">
[[1.         0.56107177]
 [0.56107177 1.        ]]
</pre>


<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">ofile</span> = os.path.join(out_dir, <span class="org-string">"cor_lambda_coordPCA_e.png"</span>)
<span class="org-variable-name">fig</span>, <span class="org-variable-name">axs</span> = plt.subplots(3, sharex=<span class="org-constant">True</span>)
axs[0].scatter(np.<span class="org-builtin">abs</span>(lambda_target[:, 0]), np.<span class="org-builtin">abs</span>(pca_comp[:, 0]), c=<span class="org-string">"b"</span>)
axs[1].scatter(np.<span class="org-builtin">abs</span>(lambda_target[:, 1]), np.<span class="org-builtin">abs</span>(pca_comp[:, 1]), c=<span class="org-string">"g"</span>)
axs[2].scatter(np.<span class="org-builtin">abs</span>(lambda_target[:, 2]), np.<span class="org-builtin">abs</span>(pca_comp[:, 2]), c=<span class="org-string">"r"</span>)
<span class="org-keyword">for</span> ax <span class="org-keyword">in</span> axs.flat:
    ax.<span class="org-builtin">set</span>(xlabel=<span class="org-string">"lambda targets (abs)"</span>, ylabel=<span class="org-string">"Coord. on\nPCA axis (abs)"</span>)
fig.savefig(ofile)
ofile
</pre>
</div>


<figure id="orgd171c68">
<img src="outputs/sim-data-3lv/cor_lambda_coordPCA_e.png" alt="cor_lambda_coordPCA_e.png">

</figure>
</div>
</div>

<div id="outline-container-org889d93d" class="outline-3">
<h3 id="org889d93d"><span class="section-number-3">8.5.</span> Statistical model with sorted species</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> pm.Model() <span class="org-keyword">as</span> <span class="org-variable-name">model_auto</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Hyperpriors</span>
    sigma_alpha = pm.HalfNormal(<span class="org-string">"sigma_alpha"</span>, sigma=1.0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Priors</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Site random effect</span>
    alpha = pm.Normal(<span class="org-string">"alpha"</span>, mu=0, sigma=sigma_alpha, shape=n_sites, dims=<span class="org-string">"sites"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Latent variables</span>
    W = pm.Normal(<span class="org-string">"W"</span>, mu=0, sigma=1, shape=(n_sites, n_q), dims=(<span class="org-string">"sites"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Species effects</span>
    beta = pm.Normal(<span class="org-string">"beta"</span>, mu=0, sigma=1, shape=(n_species, n_p), dims=(<span class="org-string">"species"</span>, <span class="org-string">"fixed_effects"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Factor loadings with constraints</span>
    Lambda = makeLambda(n_species, n_q, (<span class="org-string">"species"</span>, <span class="org-string">"latent_axis"</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Likelihood</span>
    Xbeta = pm.math.dot(X, beta.transpose())
    Wlambda = pm.math.dot(W, Lambda.transpose()) 
    logit_theta = alpha[:, np.newaxis] + Xbeta + Wlambda
    obs = pm.Bernoulli(<span class="org-string">"obs"</span>, logit_p=logit_theta, observed=Y)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Inference</span>
<span class="org-keyword">with</span> <span class="org-variable-name">model_auto</span>:
    trace_auto = pm.sample(**SAMPLE_KWARGS)
</pre>
</div>

<p>
Save model with cloudpickle.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(out_dir + <span class="org-string">"model_trace_auto.pkl"</span>, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> <span class="org-variable-name">f</span>:
     model_trace_dump = cloudpickle.dumps({<span class="org-string">'model'</span>: model_auto, <span class="org-string">'trace'</span>: trace_auto})
     f.write(model_trace_dump)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce74850" class="outline-3">
<h3 id="orgce74850"><span class="section-number-3">8.6.</span> Convergence and model performance</h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> <span class="org-variable-name">model_auto</span>:
    alpha_est = az.summary(trace_auto, var_names=[<span class="org-string">"alpha"</span>], round_to=2)
    beta_est = az.summary(trace_auto, var_names=[<span class="org-string">"beta"</span>], round_to=2)
    lambda_diag_est = az.summary(trace_auto,
                                 var_names=[<span class="org-string">"L_diag"</span>],
                                 round_to=2)
    lambda_offdiag_est = az.summary(trace_auto,
                                    var_names=[<span class="org-string">"L_packed"</span>],
                                    round_to=2)
    lambda_est = az.summary(trace_auto,
                            var_names=[<span class="org-string">"Lambda"</span>],
                            round_to=2)
    W_diag_est = az.summary(trace_auto, var_names=[<span class="org-string">"W"</span>],
                            coords={<span class="org-string">"sites"</span>: np.arange(n_q),
                                    <span class="org-string">"latent_axis"</span>: np.arange(n_q)},
                            round_to=2)
    W_est = az.summary(trace_auto, var_names=[<span class="org-string">"W"</span>],
                            round_to=2)
</pre>
</div>

<p>
We compute the mean r_hat for each category of parameters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Compute r_hat mean and std</span>
<span class="org-variable-name">rhat_alpha_mean</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_alpha_std</span> = <span class="org-builtin">round</span>(alpha_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_beta_mean</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_beta_std</span> = <span class="org-builtin">round</span>(beta_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_W_mean</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_W_std</span> = <span class="org-builtin">round</span>(W_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_mean</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_std</span> = <span class="org-builtin">round</span>(lambda_est[<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_diag_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_diag_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[0, 0]"</span>, <span class="org-string">"Lambda[1, 1]"</span>, <span class="org-string">"Lambda[2, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)
<span class="org-variable-name">rhat_lambda_high_mean</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].mean(), 2)
<span class="org-variable-name">rhat_lambda_high_std</span> = <span class="org-builtin">round</span>(lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"r_hat"</span>]][<span class="org-string">"r_hat"</span>].std(), 2)

<span class="org-comment-delimiter"># </span><span class="org-comment">Build dataframe</span>
<span class="org-variable-name">par_names</span> = [<span class="org-string">"alpha"</span>, <span class="org-string">"beta"</span>, <span class="org-string">"W"</span>, <span class="org-string">"lambda"</span>, <span class="org-string">"lambda_diag"</span>, <span class="org-string">"lambda_high"</span>]
<span class="org-variable-name">mean_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_mean"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]
<span class="org-variable-name">std_val</span> = [<span class="org-builtin">eval</span>(<span class="org-string">"rhat_"</span> + x + <span class="org-string">"_std"</span>) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> par_names]

<span class="org-variable-name">rhat_dic</span> = {<span class="org-string">"par"</span>: par_names,
            <span class="org-string">"r_hat_mean"</span>: mean_val, <span class="org-string">"rhat_std"</span>: std_val}
<span class="org-variable-name">rhat_df</span> = pd.DataFrame(rhat_dic)
tabulate(rhat_df, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">False</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">par</th>
<th scope="col" class="org-right">r_hat_mean</th>
<th scope="col" class="org-right">rhat_std</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alpha</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">beta</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">W</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">lambda</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">lambda_diag</td>
<td class="org-right">1.01</td>
<td class="org-right">0.01</td>
</tr>

<tr>
<td class="org-left">lambda_high</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">lambda_high</span> = lambda_est.loc[[<span class="org-string">"Lambda[3, 0]"</span>, <span class="org-string">"Lambda[4, 1]"</span>, <span class="org-string">"Lambda[5, 2]"</span>], [<span class="org-string">"mean"</span>, <span class="org-string">"sd"</span>, <span class="org-string">"r_hat"</span>]]
<span class="org-variable-name">lambda_high</span>[<span class="org-string">"target_value"</span>] = [lambda_target[3, 0], lambda_target[4, 1], lambda_target[5, 2]]
tabulate(lambda_high, headers=<span class="org-string">"keys"</span>, tablefmt=<span class="org-string">"orgtbl"</span>, showindex=<span class="org-constant">True</span>)
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">sd</th>
<th scope="col" class="org-right">r_hat</th>
<th scope="col" class="org-right">target_value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Lambda[3, 0]</td>
<td class="org-right">-2.68</td>
<td class="org-right">0.62</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">Lambda[4, 1]</td>
<td class="org-right">1.58</td>
<td class="org-right">0.57</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Lambda[5, 2]</td>
<td class="org-right">-0.4</td>
<td class="org-right">0.46</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</body>
</html>